// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gosesh

import (
	"context"
	"net/http"
	"sync"
	"time"
)

// Ensure, that IdentifierMock does implement Identifier.
// If this is not the case, regenerate this file with moq.
var _ Identifier = &IdentifierMock{}

// IdentifierMock is a mock implementation of Identifier.
//
//	func TestSomethingThatUsesIdentifier(t *testing.T) {
//
//		// make and configure a mocked Identifier
//		mockedIdentifier := &IdentifierMock{
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//		}
//
//		// use mockedIdentifier in code that requires Identifier
//		// and then make assertions.
//
//	}
type IdentifierMock struct {
	// StringFunc mocks the String method.
	StringFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// String holds details about calls to the String method.
		String []struct {
		}
	}
	lockString sync.RWMutex
}

// String calls StringFunc.
func (mock *IdentifierMock) String() string {
	if mock.StringFunc == nil {
		panic("IdentifierMock.StringFunc: method is nil but Identifier.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedIdentifier.StringCalls())
func (mock *IdentifierMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// ResetStringCalls reset all the calls that were made to String.
func (mock *IdentifierMock) ResetStringCalls() {
	mock.lockString.Lock()
	mock.calls.String = nil
	mock.lockString.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *IdentifierMock) ResetCalls() {
	mock.lockString.Lock()
	mock.calls.String = nil
	mock.lockString.Unlock()
}

// Ensure, that StorerMock does implement Storer.
// If this is not the case, regenerate this file with moq.
var _ Storer = &StorerMock{}

// StorerMock is a mock implementation of Storer.
//
//	func TestSomethingThatUsesStorer(t *testing.T) {
//
//		// make and configure a mocked Storer
//		mockedStorer := &StorerMock{
//			CreateSessionFunc: func(ctx context.Context, req CreateSessionRequest) (Session, error) {
//				panic("mock out the CreateSession method")
//			},
//			DeleteSessionFunc: func(ctx context.Context, sessionID Identifier) error {
//				panic("mock out the DeleteSession method")
//			},
//			DeleteUserSessionsFunc: func(ctx context.Context, userID Identifier) (int, error) {
//				panic("mock out the DeleteUserSessions method")
//			},
//			GetSessionFunc: func(ctx context.Context, sessionID Identifier) (Session, error) {
//				panic("mock out the GetSession method")
//			},
//			UpsertUserFunc: func(ctx context.Context, user OAuth2User) (Identifier, error) {
//				panic("mock out the UpsertUser method")
//			},
//		}
//
//		// use mockedStorer in code that requires Storer
//		// and then make assertions.
//
//	}
type StorerMock struct {
	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(ctx context.Context, req CreateSessionRequest) (Session, error)

	// DeleteSessionFunc mocks the DeleteSession method.
	DeleteSessionFunc func(ctx context.Context, sessionID Identifier) error

	// DeleteUserSessionsFunc mocks the DeleteUserSessions method.
	DeleteUserSessionsFunc func(ctx context.Context, userID Identifier) (int, error)

	// GetSessionFunc mocks the GetSession method.
	GetSessionFunc func(ctx context.Context, sessionID Identifier) (Session, error)

	// UpsertUserFunc mocks the UpsertUser method.
	UpsertUserFunc func(ctx context.Context, user OAuth2User) (Identifier, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req CreateSessionRequest
		}
		// DeleteSession holds details about calls to the DeleteSession method.
		DeleteSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionID is the sessionID argument value.
			SessionID Identifier
		}
		// DeleteUserSessions holds details about calls to the DeleteUserSessions method.
		DeleteUserSessions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID Identifier
		}
		// GetSession holds details about calls to the GetSession method.
		GetSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionID is the sessionID argument value.
			SessionID Identifier
		}
		// UpsertUser holds details about calls to the UpsertUser method.
		UpsertUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User OAuth2User
		}
	}
	lockCreateSession      sync.RWMutex
	lockDeleteSession      sync.RWMutex
	lockDeleteUserSessions sync.RWMutex
	lockGetSession         sync.RWMutex
	lockUpsertUser         sync.RWMutex
}

// CreateSession calls CreateSessionFunc.
func (mock *StorerMock) CreateSession(ctx context.Context, req CreateSessionRequest) (Session, error) {
	if mock.CreateSessionFunc == nil {
		panic("StorerMock.CreateSessionFunc: method is nil but Storer.CreateSession was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req CreateSessionRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	mock.lockCreateSession.Unlock()
	return mock.CreateSessionFunc(ctx, req)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//
//	len(mockedStorer.CreateSessionCalls())
func (mock *StorerMock) CreateSessionCalls() []struct {
	Ctx context.Context
	Req CreateSessionRequest
} {
	var calls []struct {
		Ctx context.Context
		Req CreateSessionRequest
	}
	mock.lockCreateSession.RLock()
	calls = mock.calls.CreateSession
	mock.lockCreateSession.RUnlock()
	return calls
}

// ResetCreateSessionCalls reset all the calls that were made to CreateSession.
func (mock *StorerMock) ResetCreateSessionCalls() {
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = nil
	mock.lockCreateSession.Unlock()
}

// DeleteSession calls DeleteSessionFunc.
func (mock *StorerMock) DeleteSession(ctx context.Context, sessionID Identifier) error {
	if mock.DeleteSessionFunc == nil {
		panic("StorerMock.DeleteSessionFunc: method is nil but Storer.DeleteSession was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SessionID Identifier
	}{
		Ctx:       ctx,
		SessionID: sessionID,
	}
	mock.lockDeleteSession.Lock()
	mock.calls.DeleteSession = append(mock.calls.DeleteSession, callInfo)
	mock.lockDeleteSession.Unlock()
	return mock.DeleteSessionFunc(ctx, sessionID)
}

// DeleteSessionCalls gets all the calls that were made to DeleteSession.
// Check the length with:
//
//	len(mockedStorer.DeleteSessionCalls())
func (mock *StorerMock) DeleteSessionCalls() []struct {
	Ctx       context.Context
	SessionID Identifier
} {
	var calls []struct {
		Ctx       context.Context
		SessionID Identifier
	}
	mock.lockDeleteSession.RLock()
	calls = mock.calls.DeleteSession
	mock.lockDeleteSession.RUnlock()
	return calls
}

// ResetDeleteSessionCalls reset all the calls that were made to DeleteSession.
func (mock *StorerMock) ResetDeleteSessionCalls() {
	mock.lockDeleteSession.Lock()
	mock.calls.DeleteSession = nil
	mock.lockDeleteSession.Unlock()
}

// DeleteUserSessions calls DeleteUserSessionsFunc.
func (mock *StorerMock) DeleteUserSessions(ctx context.Context, userID Identifier) (int, error) {
	if mock.DeleteUserSessionsFunc == nil {
		panic("StorerMock.DeleteUserSessionsFunc: method is nil but Storer.DeleteUserSessions was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID Identifier
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockDeleteUserSessions.Lock()
	mock.calls.DeleteUserSessions = append(mock.calls.DeleteUserSessions, callInfo)
	mock.lockDeleteUserSessions.Unlock()
	return mock.DeleteUserSessionsFunc(ctx, userID)
}

// DeleteUserSessionsCalls gets all the calls that were made to DeleteUserSessions.
// Check the length with:
//
//	len(mockedStorer.DeleteUserSessionsCalls())
func (mock *StorerMock) DeleteUserSessionsCalls() []struct {
	Ctx    context.Context
	UserID Identifier
} {
	var calls []struct {
		Ctx    context.Context
		UserID Identifier
	}
	mock.lockDeleteUserSessions.RLock()
	calls = mock.calls.DeleteUserSessions
	mock.lockDeleteUserSessions.RUnlock()
	return calls
}

// ResetDeleteUserSessionsCalls reset all the calls that were made to DeleteUserSessions.
func (mock *StorerMock) ResetDeleteUserSessionsCalls() {
	mock.lockDeleteUserSessions.Lock()
	mock.calls.DeleteUserSessions = nil
	mock.lockDeleteUserSessions.Unlock()
}

// GetSession calls GetSessionFunc.
func (mock *StorerMock) GetSession(ctx context.Context, sessionID Identifier) (Session, error) {
	if mock.GetSessionFunc == nil {
		panic("StorerMock.GetSessionFunc: method is nil but Storer.GetSession was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SessionID Identifier
	}{
		Ctx:       ctx,
		SessionID: sessionID,
	}
	mock.lockGetSession.Lock()
	mock.calls.GetSession = append(mock.calls.GetSession, callInfo)
	mock.lockGetSession.Unlock()
	return mock.GetSessionFunc(ctx, sessionID)
}

// GetSessionCalls gets all the calls that were made to GetSession.
// Check the length with:
//
//	len(mockedStorer.GetSessionCalls())
func (mock *StorerMock) GetSessionCalls() []struct {
	Ctx       context.Context
	SessionID Identifier
} {
	var calls []struct {
		Ctx       context.Context
		SessionID Identifier
	}
	mock.lockGetSession.RLock()
	calls = mock.calls.GetSession
	mock.lockGetSession.RUnlock()
	return calls
}

// ResetGetSessionCalls reset all the calls that were made to GetSession.
func (mock *StorerMock) ResetGetSessionCalls() {
	mock.lockGetSession.Lock()
	mock.calls.GetSession = nil
	mock.lockGetSession.Unlock()
}

// UpsertUser calls UpsertUserFunc.
func (mock *StorerMock) UpsertUser(ctx context.Context, user OAuth2User) (Identifier, error) {
	if mock.UpsertUserFunc == nil {
		panic("StorerMock.UpsertUserFunc: method is nil but Storer.UpsertUser was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User OAuth2User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockUpsertUser.Lock()
	mock.calls.UpsertUser = append(mock.calls.UpsertUser, callInfo)
	mock.lockUpsertUser.Unlock()
	return mock.UpsertUserFunc(ctx, user)
}

// UpsertUserCalls gets all the calls that were made to UpsertUser.
// Check the length with:
//
//	len(mockedStorer.UpsertUserCalls())
func (mock *StorerMock) UpsertUserCalls() []struct {
	Ctx  context.Context
	User OAuth2User
} {
	var calls []struct {
		Ctx  context.Context
		User OAuth2User
	}
	mock.lockUpsertUser.RLock()
	calls = mock.calls.UpsertUser
	mock.lockUpsertUser.RUnlock()
	return calls
}

// ResetUpsertUserCalls reset all the calls that were made to UpsertUser.
func (mock *StorerMock) ResetUpsertUserCalls() {
	mock.lockUpsertUser.Lock()
	mock.calls.UpsertUser = nil
	mock.lockUpsertUser.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *StorerMock) ResetCalls() {
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = nil
	mock.lockCreateSession.Unlock()

	mock.lockDeleteSession.Lock()
	mock.calls.DeleteSession = nil
	mock.lockDeleteSession.Unlock()

	mock.lockDeleteUserSessions.Lock()
	mock.calls.DeleteUserSessions = nil
	mock.lockDeleteUserSessions.Unlock()

	mock.lockGetSession.Lock()
	mock.calls.GetSession = nil
	mock.lockGetSession.Unlock()

	mock.lockUpsertUser.Lock()
	mock.calls.UpsertUser = nil
	mock.lockUpsertUser.Unlock()
}

// Ensure, that SessionMock does implement Session.
// If this is not the case, regenerate this file with moq.
var _ Session = &SessionMock{}

// SessionMock is a mock implementation of Session.
//
//	func TestSomethingThatUsesSession(t *testing.T) {
//
//		// make and configure a mocked Session
//		mockedSession := &SessionMock{
//			ExpireAtFunc: func() time.Time {
//				panic("mock out the ExpireAt method")
//			},
//			IDFunc: func() Identifier {
//				panic("mock out the ID method")
//			},
//			IdleAtFunc: func() time.Time {
//				panic("mock out the IdleAt method")
//			},
//			UserIDFunc: func() Identifier {
//				panic("mock out the UserID method")
//			},
//		}
//
//		// use mockedSession in code that requires Session
//		// and then make assertions.
//
//	}
type SessionMock struct {
	// ExpireAtFunc mocks the ExpireAt method.
	ExpireAtFunc func() time.Time

	// IDFunc mocks the ID method.
	IDFunc func() Identifier

	// IdleAtFunc mocks the IdleAt method.
	IdleAtFunc func() time.Time

	// UserIDFunc mocks the UserID method.
	UserIDFunc func() Identifier

	// calls tracks calls to the methods.
	calls struct {
		// ExpireAt holds details about calls to the ExpireAt method.
		ExpireAt []struct {
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// IdleAt holds details about calls to the IdleAt method.
		IdleAt []struct {
		}
		// UserID holds details about calls to the UserID method.
		UserID []struct {
		}
	}
	lockExpireAt sync.RWMutex
	lockID       sync.RWMutex
	lockIdleAt   sync.RWMutex
	lockUserID   sync.RWMutex
}

// ExpireAt calls ExpireAtFunc.
func (mock *SessionMock) ExpireAt() time.Time {
	if mock.ExpireAtFunc == nil {
		panic("SessionMock.ExpireAtFunc: method is nil but Session.ExpireAt was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExpireAt.Lock()
	mock.calls.ExpireAt = append(mock.calls.ExpireAt, callInfo)
	mock.lockExpireAt.Unlock()
	return mock.ExpireAtFunc()
}

// ExpireAtCalls gets all the calls that were made to ExpireAt.
// Check the length with:
//
//	len(mockedSession.ExpireAtCalls())
func (mock *SessionMock) ExpireAtCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExpireAt.RLock()
	calls = mock.calls.ExpireAt
	mock.lockExpireAt.RUnlock()
	return calls
}

// ResetExpireAtCalls reset all the calls that were made to ExpireAt.
func (mock *SessionMock) ResetExpireAtCalls() {
	mock.lockExpireAt.Lock()
	mock.calls.ExpireAt = nil
	mock.lockExpireAt.Unlock()
}

// ID calls IDFunc.
func (mock *SessionMock) ID() Identifier {
	if mock.IDFunc == nil {
		panic("SessionMock.IDFunc: method is nil but Session.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//
//	len(mockedSession.IDCalls())
func (mock *SessionMock) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// ResetIDCalls reset all the calls that were made to ID.
func (mock *SessionMock) ResetIDCalls() {
	mock.lockID.Lock()
	mock.calls.ID = nil
	mock.lockID.Unlock()
}

// IdleAt calls IdleAtFunc.
func (mock *SessionMock) IdleAt() time.Time {
	if mock.IdleAtFunc == nil {
		panic("SessionMock.IdleAtFunc: method is nil but Session.IdleAt was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIdleAt.Lock()
	mock.calls.IdleAt = append(mock.calls.IdleAt, callInfo)
	mock.lockIdleAt.Unlock()
	return mock.IdleAtFunc()
}

// IdleAtCalls gets all the calls that were made to IdleAt.
// Check the length with:
//
//	len(mockedSession.IdleAtCalls())
func (mock *SessionMock) IdleAtCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIdleAt.RLock()
	calls = mock.calls.IdleAt
	mock.lockIdleAt.RUnlock()
	return calls
}

// ResetIdleAtCalls reset all the calls that were made to IdleAt.
func (mock *SessionMock) ResetIdleAtCalls() {
	mock.lockIdleAt.Lock()
	mock.calls.IdleAt = nil
	mock.lockIdleAt.Unlock()
}

// UserID calls UserIDFunc.
func (mock *SessionMock) UserID() Identifier {
	if mock.UserIDFunc == nil {
		panic("SessionMock.UserIDFunc: method is nil but Session.UserID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUserID.Lock()
	mock.calls.UserID = append(mock.calls.UserID, callInfo)
	mock.lockUserID.Unlock()
	return mock.UserIDFunc()
}

// UserIDCalls gets all the calls that were made to UserID.
// Check the length with:
//
//	len(mockedSession.UserIDCalls())
func (mock *SessionMock) UserIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUserID.RLock()
	calls = mock.calls.UserID
	mock.lockUserID.RUnlock()
	return calls
}

// ResetUserIDCalls reset all the calls that were made to UserID.
func (mock *SessionMock) ResetUserIDCalls() {
	mock.lockUserID.Lock()
	mock.calls.UserID = nil
	mock.lockUserID.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SessionMock) ResetCalls() {
	mock.lockExpireAt.Lock()
	mock.calls.ExpireAt = nil
	mock.lockExpireAt.Unlock()

	mock.lockID.Lock()
	mock.calls.ID = nil
	mock.lockID.Unlock()

	mock.lockIdleAt.Lock()
	mock.calls.IdleAt = nil
	mock.lockIdleAt.Unlock()

	mock.lockUserID.Lock()
	mock.calls.UserID = nil
	mock.lockUserID.Unlock()
}

// Ensure, that OAuth2UserMock does implement OAuth2User.
// If this is not the case, regenerate this file with moq.
var _ OAuth2User = &OAuth2UserMock{}

// OAuth2UserMock is a mock implementation of OAuth2User.
//
//	func TestSomethingThatUsesOAuth2User(t *testing.T) {
//
//		// make and configure a mocked OAuth2User
//		mockedOAuth2User := &OAuth2UserMock{
//			RequestFunc: func(ctx context.Context, accessToken string) (*http.Response, error) {
//				panic("mock out the Request method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//			UnmarshalFunc: func(b []byte) error {
//				panic("mock out the Unmarshal method")
//			},
//		}
//
//		// use mockedOAuth2User in code that requires OAuth2User
//		// and then make assertions.
//
//	}
type OAuth2UserMock struct {
	// RequestFunc mocks the Request method.
	RequestFunc func(ctx context.Context, accessToken string) (*http.Response, error)

	// StringFunc mocks the String method.
	StringFunc func() string

	// UnmarshalFunc mocks the Unmarshal method.
	UnmarshalFunc func(b []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// Request holds details about calls to the Request method.
		Request []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccessToken is the accessToken argument value.
			AccessToken string
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Unmarshal holds details about calls to the Unmarshal method.
		Unmarshal []struct {
			// B is the b argument value.
			B []byte
		}
	}
	lockRequest   sync.RWMutex
	lockString    sync.RWMutex
	lockUnmarshal sync.RWMutex
}

// Request calls RequestFunc.
func (mock *OAuth2UserMock) Request(ctx context.Context, accessToken string) (*http.Response, error) {
	if mock.RequestFunc == nil {
		panic("OAuth2UserMock.RequestFunc: method is nil but OAuth2User.Request was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		AccessToken string
	}{
		Ctx:         ctx,
		AccessToken: accessToken,
	}
	mock.lockRequest.Lock()
	mock.calls.Request = append(mock.calls.Request, callInfo)
	mock.lockRequest.Unlock()
	return mock.RequestFunc(ctx, accessToken)
}

// RequestCalls gets all the calls that were made to Request.
// Check the length with:
//
//	len(mockedOAuth2User.RequestCalls())
func (mock *OAuth2UserMock) RequestCalls() []struct {
	Ctx         context.Context
	AccessToken string
} {
	var calls []struct {
		Ctx         context.Context
		AccessToken string
	}
	mock.lockRequest.RLock()
	calls = mock.calls.Request
	mock.lockRequest.RUnlock()
	return calls
}

// ResetRequestCalls reset all the calls that were made to Request.
func (mock *OAuth2UserMock) ResetRequestCalls() {
	mock.lockRequest.Lock()
	mock.calls.Request = nil
	mock.lockRequest.Unlock()
}

// String calls StringFunc.
func (mock *OAuth2UserMock) String() string {
	if mock.StringFunc == nil {
		panic("OAuth2UserMock.StringFunc: method is nil but OAuth2User.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedOAuth2User.StringCalls())
func (mock *OAuth2UserMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// ResetStringCalls reset all the calls that were made to String.
func (mock *OAuth2UserMock) ResetStringCalls() {
	mock.lockString.Lock()
	mock.calls.String = nil
	mock.lockString.Unlock()
}

// Unmarshal calls UnmarshalFunc.
func (mock *OAuth2UserMock) Unmarshal(b []byte) error {
	if mock.UnmarshalFunc == nil {
		panic("OAuth2UserMock.UnmarshalFunc: method is nil but OAuth2User.Unmarshal was just called")
	}
	callInfo := struct {
		B []byte
	}{
		B: b,
	}
	mock.lockUnmarshal.Lock()
	mock.calls.Unmarshal = append(mock.calls.Unmarshal, callInfo)
	mock.lockUnmarshal.Unlock()
	return mock.UnmarshalFunc(b)
}

// UnmarshalCalls gets all the calls that were made to Unmarshal.
// Check the length with:
//
//	len(mockedOAuth2User.UnmarshalCalls())
func (mock *OAuth2UserMock) UnmarshalCalls() []struct {
	B []byte
} {
	var calls []struct {
		B []byte
	}
	mock.lockUnmarshal.RLock()
	calls = mock.calls.Unmarshal
	mock.lockUnmarshal.RUnlock()
	return calls
}

// ResetUnmarshalCalls reset all the calls that were made to Unmarshal.
func (mock *OAuth2UserMock) ResetUnmarshalCalls() {
	mock.lockUnmarshal.Lock()
	mock.calls.Unmarshal = nil
	mock.lockUnmarshal.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *OAuth2UserMock) ResetCalls() {
	mock.lockRequest.Lock()
	mock.calls.Request = nil
	mock.lockRequest.Unlock()

	mock.lockString.Lock()
	mock.calls.String = nil
	mock.lockString.Unlock()

	mock.lockUnmarshal.Lock()
	mock.calls.Unmarshal = nil
	mock.lockUnmarshal.Unlock()
}

// Ensure, that OAuth2CredentialsMock does implement OAuth2Credentials.
// If this is not the case, regenerate this file with moq.
var _ OAuth2Credentials = &OAuth2CredentialsMock{}

// OAuth2CredentialsMock is a mock implementation of OAuth2Credentials.
//
//	func TestSomethingThatUsesOAuth2Credentials(t *testing.T) {
//
//		// make and configure a mocked OAuth2Credentials
//		mockedOAuth2Credentials := &OAuth2CredentialsMock{
//			ClientIDFunc: func() string {
//				panic("mock out the ClientID method")
//			},
//			ClientSecretFunc: func() string {
//				panic("mock out the ClientSecret method")
//			},
//		}
//
//		// use mockedOAuth2Credentials in code that requires OAuth2Credentials
//		// and then make assertions.
//
//	}
type OAuth2CredentialsMock struct {
	// ClientIDFunc mocks the ClientID method.
	ClientIDFunc func() string

	// ClientSecretFunc mocks the ClientSecret method.
	ClientSecretFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// ClientID holds details about calls to the ClientID method.
		ClientID []struct {
		}
		// ClientSecret holds details about calls to the ClientSecret method.
		ClientSecret []struct {
		}
	}
	lockClientID     sync.RWMutex
	lockClientSecret sync.RWMutex
}

// ClientID calls ClientIDFunc.
func (mock *OAuth2CredentialsMock) ClientID() string {
	if mock.ClientIDFunc == nil {
		panic("OAuth2CredentialsMock.ClientIDFunc: method is nil but OAuth2Credentials.ClientID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClientID.Lock()
	mock.calls.ClientID = append(mock.calls.ClientID, callInfo)
	mock.lockClientID.Unlock()
	return mock.ClientIDFunc()
}

// ClientIDCalls gets all the calls that were made to ClientID.
// Check the length with:
//
//	len(mockedOAuth2Credentials.ClientIDCalls())
func (mock *OAuth2CredentialsMock) ClientIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClientID.RLock()
	calls = mock.calls.ClientID
	mock.lockClientID.RUnlock()
	return calls
}

// ResetClientIDCalls reset all the calls that were made to ClientID.
func (mock *OAuth2CredentialsMock) ResetClientIDCalls() {
	mock.lockClientID.Lock()
	mock.calls.ClientID = nil
	mock.lockClientID.Unlock()
}

// ClientSecret calls ClientSecretFunc.
func (mock *OAuth2CredentialsMock) ClientSecret() string {
	if mock.ClientSecretFunc == nil {
		panic("OAuth2CredentialsMock.ClientSecretFunc: method is nil but OAuth2Credentials.ClientSecret was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClientSecret.Lock()
	mock.calls.ClientSecret = append(mock.calls.ClientSecret, callInfo)
	mock.lockClientSecret.Unlock()
	return mock.ClientSecretFunc()
}

// ClientSecretCalls gets all the calls that were made to ClientSecret.
// Check the length with:
//
//	len(mockedOAuth2Credentials.ClientSecretCalls())
func (mock *OAuth2CredentialsMock) ClientSecretCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClientSecret.RLock()
	calls = mock.calls.ClientSecret
	mock.lockClientSecret.RUnlock()
	return calls
}

// ResetClientSecretCalls reset all the calls that were made to ClientSecret.
func (mock *OAuth2CredentialsMock) ResetClientSecretCalls() {
	mock.lockClientSecret.Lock()
	mock.calls.ClientSecret = nil
	mock.lockClientSecret.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *OAuth2CredentialsMock) ResetCalls() {
	mock.lockClientID.Lock()
	mock.calls.ClientID = nil
	mock.lockClientID.Unlock()

	mock.lockClientSecret.Lock()
	mock.calls.ClientSecret = nil
	mock.lockClientSecret.Unlock()
}
