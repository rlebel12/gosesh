// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gosesh

import (
	"sync"
)

// Ensure, that OAuth2CredentialsMock does implement OAuth2Credentials.
// If this is not the case, regenerate this file with moq.
var _ OAuth2Credentials = &OAuth2CredentialsMock{}

// OAuth2CredentialsMock is a mock implementation of OAuth2Credentials.
//
//	func TestSomethingThatUsesOAuth2Credentials(t *testing.T) {
//
//		// make and configure a mocked OAuth2Credentials
//		mockedOAuth2Credentials := &OAuth2CredentialsMock{
//			ClientIDFunc: func() string {
//				panic("mock out the ClientID method")
//			},
//			ClientSecretFunc: func() string {
//				panic("mock out the ClientSecret method")
//			},
//		}
//
//		// use mockedOAuth2Credentials in code that requires OAuth2Credentials
//		// and then make assertions.
//
//	}
type OAuth2CredentialsMock struct {
	// ClientIDFunc mocks the ClientID method.
	ClientIDFunc func() string

	// ClientSecretFunc mocks the ClientSecret method.
	ClientSecretFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// ClientID holds details about calls to the ClientID method.
		ClientID []struct {
		}
		// ClientSecret holds details about calls to the ClientSecret method.
		ClientSecret []struct {
		}
	}
	lockClientID     sync.RWMutex
	lockClientSecret sync.RWMutex
}

// ClientID calls ClientIDFunc.
func (mock *OAuth2CredentialsMock) ClientID() string {
	if mock.ClientIDFunc == nil {
		panic("OAuth2CredentialsMock.ClientIDFunc: method is nil but OAuth2Credentials.ClientID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClientID.Lock()
	mock.calls.ClientID = append(mock.calls.ClientID, callInfo)
	mock.lockClientID.Unlock()
	return mock.ClientIDFunc()
}

// ClientIDCalls gets all the calls that were made to ClientID.
// Check the length with:
//
//	len(mockedOAuth2Credentials.ClientIDCalls())
func (mock *OAuth2CredentialsMock) ClientIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClientID.RLock()
	calls = mock.calls.ClientID
	mock.lockClientID.RUnlock()
	return calls
}

// ResetClientIDCalls reset all the calls that were made to ClientID.
func (mock *OAuth2CredentialsMock) ResetClientIDCalls() {
	mock.lockClientID.Lock()
	mock.calls.ClientID = nil
	mock.lockClientID.Unlock()
}

// ClientSecret calls ClientSecretFunc.
func (mock *OAuth2CredentialsMock) ClientSecret() string {
	if mock.ClientSecretFunc == nil {
		panic("OAuth2CredentialsMock.ClientSecretFunc: method is nil but OAuth2Credentials.ClientSecret was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClientSecret.Lock()
	mock.calls.ClientSecret = append(mock.calls.ClientSecret, callInfo)
	mock.lockClientSecret.Unlock()
	return mock.ClientSecretFunc()
}

// ClientSecretCalls gets all the calls that were made to ClientSecret.
// Check the length with:
//
//	len(mockedOAuth2Credentials.ClientSecretCalls())
func (mock *OAuth2CredentialsMock) ClientSecretCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClientSecret.RLock()
	calls = mock.calls.ClientSecret
	mock.lockClientSecret.RUnlock()
	return calls
}

// ResetClientSecretCalls reset all the calls that were made to ClientSecret.
func (mock *OAuth2CredentialsMock) ResetClientSecretCalls() {
	mock.lockClientSecret.Lock()
	mock.calls.ClientSecret = nil
	mock.lockClientSecret.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *OAuth2CredentialsMock) ResetCalls() {
	mock.lockClientID.Lock()
	mock.calls.ClientID = nil
	mock.lockClientID.Unlock()

	mock.lockClientSecret.Lock()
	mock.calls.ClientSecret = nil
	mock.lockClientSecret.Unlock()
}
